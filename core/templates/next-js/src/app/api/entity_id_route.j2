import { NextRequest, NextResponse } from 'next/server';
import { db } from '@/lib/db';
import { {{ entity_name }} } from '@/drizzle/schema';
import { update{{ EntityName }}Schema } from '@/lib/validations';
import { eq } from 'drizzle-orm';

export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    {% set id_column = entity.attributes | selectattr('pk') | first %}
    {% if 'int' in id_column.type.lower() or 'serial' in id_column.type.lower() %}
    const id = parseInt(params.id);
    if (isNaN(id)) {
      return NextResponse.json(
        { error: 'Invalid {{ entityName }} ID' },
        { status: 400 }
      );
    }
    {% else %}
    const id = params.id;
    if (!id) {
      return NextResponse.json(
        { error: 'Invalid {{ entityName }} ID' },
        { status: 400 }
      );
    }
    {% endif %}

    const [{{ entityName }}] = await db
      .select()
      .from({{ entity_name }})
      .where(eq({{ entity_name }}.{{ id_column.names.snake_case.singular }}, id));

    if (!{{ entityName }}) {
      return NextResponse.json(
        { error: '{{ EntityName }} not found' },
        { status: 404 }
      );
    }

    return NextResponse.json({{ entityName }});
  } catch (error) {
    console.error('Error fetching {{ entityName }}:', error);
    return NextResponse.json(
      { error: 'Failed to fetch {{ entityName }}' },
      { status: 500 }
    );
  }
}

export async function PUT(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    {% if 'int' in id_column.type.lower() or 'serial' in id_column.type.lower() %}
    const id = parseInt(params.id);
    if (isNaN(id)) {
      return NextResponse.json(
        { error: 'Invalid {{ entityName }} ID' },
        { status: 400 }
      );
    }
    {% else %}
    const id = params.id;
    if (!id) {
      return NextResponse.json(
        { error: 'Invalid {{ entityName }} ID' },
        { status: 400 }
      );
    }
    {% endif %}

    const body = await request.json();
    const validatedData = update{{ EntityName }}Schema.parse(body);

    const [updated{{ EntityName }}] = await db
      .update({{ entity_name }})
      .set(validatedData)
      .where(eq({{ entity_name }}.{{ id_column.names.snake_case.singular }}, id))
      .returning();

    if (!updated{{ EntityName }}) {
      return NextResponse.json(
        { error: '{{ EntityName }} not found' },
        { status: 404 }
      );
    }

    return NextResponse.json(updated{{ EntityName }});
  } catch (error) {
    console.error('Error updating {{ entityName }}:', error);
    return NextResponse.json(
      { error: 'Failed to update {{ entityName }}' },
      { status: 500 }
    );
  }
}

export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    {% if 'int' in id_column.type.lower() or 'serial' in id_column.type.lower() %}
    const id = parseInt(params.id);
    if (isNaN(id)) {
      return NextResponse.json(
        { error: 'Invalid {{ entityName }} ID' },
        { status: 400 }
      );
    }
    {% else %}
    const id = params.id;
    if (!id) {
      return NextResponse.json(
        { error: 'Invalid {{ entityName }} ID' },
        { status: 400 }
      );
    }
    {% endif %}

    const [deleted{{ EntityName }}] = await db
      .delete({{ entity_name }})
      .where(eq({{ entity_name }}.{{ id_column.names.snake_case.singular }}, id))
      .returning();

    if (!deleted{{ EntityName }}) {
      return NextResponse.json(
        { error: '{{ EntityName }} not found' },
        { status: 404 }
      );
    }

    return NextResponse.json({ message: '{{ EntityName }} deleted successfully' });
  } catch (error) {
    console.error('Error deleting {{ entityName }}:', error);
    return NextResponse.json(
      { error: 'Failed to delete {{ entityName }}' },
      { status: 500 }
    );
  }
}