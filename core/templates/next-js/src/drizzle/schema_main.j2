import { pgTable, serial, varchar, text, integer, timestamp, primaryKey, boolean, bigint, decimal, real, doublePrecision, date, json, jsonb, bigserial } from 'drizzle-orm/pg-core';
import { relations } from 'drizzle-orm';

{% for entity in entities %}
export const {{ entity.table_name }} = pgTable('{{ entity.table_name }}', {
{% for attr in schema.entities[loop.index0].attributes %}
  {{ attr.names.snake_case.singular }}: {% if attr.type.lower() == 'serial' %}serial('{{ attr.names.snake_case.singular }}'){% elif attr.type.lower() == 'bigserial' %}bigserial('{{ attr.names.snake_case.singular }}'){% elif attr.type.lower().contains('int') and not attr.type.lower().contains('bigint') %}integer('{{ attr.names.snake_case.singular }}'){% elif attr.type.lower().contains('bigint') %}bigint('{{ attr.names.snake_case.singular }}'){% elif attr.type.lower().contains('varchar') or attr.type.lower().contains('char') %}varchar('{{ attr.names.snake_case.singular }}'{% if attr.length %}, { length: {{ attr.length }} }{% endif %}){% elif attr.type.lower().contains('text') %}text('{{ attr.names.snake_case.singular }}'){% elif attr.type.lower().contains('bool') %}boolean('{{ attr.names.snake_case.singular }}'){% elif attr.type.lower() == 'date' %}date('{{ attr.names.snake_case.singular }}'){% elif attr.type.lower().contains('timestamp') or attr.type.lower().contains('datetime') %}timestamp('{{ attr.names.snake_case.singular }}'){% elif attr.type.lower().contains('decimal') or attr.type.lower().contains('numeric') %}decimal('{{ attr.names.snake_case.singular }}'){% elif attr.type.lower().contains('float') %}real('{{ attr.names.snake_case.singular }}'){% elif attr.type.lower().contains('double') %}doublePrecision('{{ attr.names.snake_case.singular }}'){% elif attr.type.lower().contains('json') and not attr.type.lower().contains('jsonb') %}json('{{ attr.names.snake_case.singular }}'){% elif attr.type.lower().contains('jsonb') %}jsonb('{{ attr.names.snake_case.singular }}'){% else %}varchar('{{ attr.names.snake_case.singular }}'){% endif %}{% if attr.pk %}.primaryKey(){% endif %}{% if attr.not_null %}.notNull(){% endif %}{% if attr.unique %}.unique(){% endif %}{% if attr.default %}.default({{ attr.default }}){% endif %}{% if attr.names.snake_case.singular == 'created_at' or attr.names.snake_case.singular == 'updated_at' %}.defaultNow(){% endif %}{% if not loop.last %},{% endif %}
{% endfor %}
}{% if schema.entities[loop.index0].attributes | selectattr('pk') | list | length > 1 %}, (table) => ({
  pk: primaryKey({ columns: [{% for attr in schema.entities[loop.index0].attributes | selectattr('pk') %}table.{{ attr.names.snake_case.singular }}{% if not loop.last %}, {% endif %}{% endfor %}] }),
}){% endif %});

{% endfor %}

{% for entity in entities %}
{% set entity_data = schema.entities[loop.index0] %}
// Relations for {{ entity.EntityName }}
export const {{ entity_data.names.camel_case.singular }}Relations = relations({{ entity_data.names.camel_case.singular }}, ({ one, many }) => ({
{% for ref in schema.database_schema.refs %}
  {% if ref.col1.table_name == entity_data.names.snake_case.singular %}
    {% if ref.type == '>' %}
  {{ ref.col2.table_name }}: one({{ ref.col2.table_name }}, {
    fields: [{{ entity_data.names.camel_case.singular }}.{{ ref.col1.name }}],
    references: [{{ ref.col2.table_name }}.{{ ref.col2.name }}],
  }),
    {% endif %}
  {% elif ref.col2.table_name == entity_data.names.snake_case.singular %}
    {% if ref.type == '>' %}
  {{ ref.col1.table_name }}: many({{ ref.col1.table_name }}),
    {% elif ref.type == '<' %}
  {{ ref.col1.table_name }}: one({{ ref.col1.table_name }}, {
    fields: [{{ entity_data.names.camel_case.singular }}.{{ ref.col2.name }}],
    references: [{{ ref.col1.table_name }}.{{ ref.col1.name }}],
  }),
    {% endif %}
  {% endif %}
{% endfor %}
}));

{% endfor %}

// Export all types
{% for entity in entities %}
export type {{ schema.entities[loop.index0].names.pascal_case.singular }} = typeof {{ schema.entities[loop.index0].names.camel_case.singular }}.$inferSelect;
export type New{{ schema.entities[loop.index0].names.pascal_case.singular }} = typeof {{ schema.entities[loop.index0].names.camel_case.singular }}.$inferInsert;
{% endfor %}